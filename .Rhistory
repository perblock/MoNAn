mobTransfers <- cbind(match(mobility_PM$occfather, mcCodes), match(mobility_PM$occresp, mcCodes))
# generate node variable
mesoClass <- mctable_PM$mesoclass
sameMesoClassProf <- 1*(mesoClass == 1) %*% t(1*(mesoClass == 1))
sameMesoManagOffic <- 1*(mesoClass == 2) %*% t(1*(mesoClass == 2))
sameMesoOtherProf <- 1*(mesoClass == 3) %*% t(1*(mesoClass == 3))
sameMesoClass <- sameMesoClassProf + sameMesoManagOffic + sameMesoOtherProf
# generate a random binary variable for individuals
sex.f <- sample(c(0,1), nrow(mobility_PM), replace = T)
##########################
# all of the above was data
# preparation outside of the "package"
##########################
######### now the real thing ###########
# 1. create a "state", i.e. put all needed data in a format that can be used by the "package"
state <- createProcessState(list(
transfers = createEdgelist( mobTransfers, nodeSet = c("micro_class", "micro_class", "people") ),
people = createNodeSet( 1:nrow(mobTransfers) ),
micro_class = createNodeSet(1:nrow(matchingTable)),
sameMesoClass = createNetwork(sameMesoClass, nodeSet = c("micro_class", "micro_class")),
sex.f = createNodeVariable(sex.f, nodeSet = "people"),
siops = createNodeVariable(mctable_PM$siops08, nodeSet = "micro_class", addSim = T)
)
)
# 2. create cache, i.e. an intermediate object that stores useful data transformations
dependentVariable <- "transfers"
cache <- createWeightedCache(state, dependentVariable, resourceCovariates = c("sex.f"))
# 3. create an effects object, i.e. specifying the "independent variables" and endogenous structures
myEffects <- createEffectsObject(
list(
list('loops'),
list('dyadic_covariate', attribute.index = "sameMesoClass")
)
)
myEffects2 <- createEffectsObject(
list(
list('loops'),
list('min_reciprocity'),
list('loops_resource_covar', resource.attribute.index = "sex.f")
)
)
# 3.5 (optional) generate "cheated" estimates as starting values
# these cheated values are the true values in case there are no endogenous parameters
statisticsFrame <- getMultinomialStatistics(state, cache, myEffects, dependentVariable)
mlogit.dataframe <- dfidx(statisticsFrame,
shape = "long",
choice = "choice")
colnames(mlogit.dataframe) <- gsub(" ", "_", colnames(mlogit.dataframe))
IVs <- (colnames(mlogit.dataframe)[2:(ncol(statisticsFrame)-2)])
f <- as.formula(paste("choice ~ 1 + ", paste(IVs, collapse = " + "), "| 0"))
mlogit.results <- mlogit(formula = eval(f), data = mlogit.dataframe, heterosc = F)
summary(mlogit.results)
# same with second effects obj
statisticsFrame2 <- getMultinomialStatistics(state, cache, myEffects2, dependentVariable)
mlogit.dataframe2 <- dfidx(statisticsFrame2,
shape = "long",
choice = "choice")
colnames(mlogit.dataframe2) <- gsub(" ", "_", colnames(mlogit.dataframe2))
IVs <- (colnames(mlogit.dataframe2)[2:(ncol(statisticsFrame2)-2)])
f <- as.formula(paste("choice ~ 1 + ", paste(IVs, collapse = " + "), "| 0"))
mlogit.results2 <- mlogit(formula = eval(f), data = mlogit.dataframe2, heterosc = F)
summary(mlogit.results2)
# 4. estimate it!
initEst <- mlogit.results2$coefficients[1:length(IVs)]
?print
t1 <- Sys.time()
set.seed(75)
resDN <- estimateDistributionNetwork(dependentVariable, state, cache, myEffects2,
initialParameters = initEst,
burnInN1 = 200, iterationsN1 = 50, thinningN1 = 2000, gainN1 = 0.1,
burnInN2 = 2000, nsubN2 = 4, initGain = 0.25, thinningN2 = 2000,
initialIterationsN2 = 25,
iterationsN3 = 500, burnInN3 = 2000, thinningN3 = 2000,
parallel = T, cpus = 4,
allowLoops = T,
verbose = T,
returnDeps = T,
multinomialProposal = T,
fish = F)
t2 <- Sys.time()
# if this value is above 0.1, the estimation has not yet converged and needs to be re-run
max(abs(resDN$convergenceStatistics))
resDN
autoCorrelationTestNetDist(dependentVariable, resDN)
traces <- extractTracesNetDist(dependentVariable, resDN, myEffects2)
plot(traces)
plot.traces.netdist(traces)
myEffects3 <- createEffectsObject(
list(
list('loops'),
list('min_reciprocity'),
list('loops_resource_covar', resource.attribute.index = "sex.f"),
list('min_transitivity')
)
)
test_ME.3 <- scoreTestNetDist(dependentVariable, resDN, myEffects3)
test_ME.3
getIndegree <- function(cache, dep.var, lvls, ...){
m <- cache[[dep.var]]$valuedNetwork
v <- cbind(lvls, 0)
existing_v <- as.numeric(names(table(colSums(m))))+1
v[existing_v[existing_v %in% lvls],2] <- table(colSums(m))[existing_v %in% lvls]
v[,2]
}
gof.indegree.1 <- gofDistributionNetwork(ans = resDN, simulations = resDN$deps, gofFunction = getIndegree, lvls = 1:100)
plot(gof.indegree.1)
plot.gof.Stats.netDist(gof.indegree.1)
getTieWeights <- function(cache, dep.var, lvls, ...){
m <- cache[[dep.var]]$valuedNetwork
if(is.null(lvls)) lvls <- 0:max(m)
v <- cbind(lvls, 0)
existing_v <- as.numeric(names(table(m)))+1
v[existing_v[existing_v %in% lvls],2] <- table(m)[existing_v %in% lvls]
v[,2]
}
gof.tie.weights.1 <- gofDistributionNetwork(ans = resDN, simulations = resDN$deps, gofFunction = getTieWeights, lvls = 1:30)
plot(gof.tie.weights.1)
plot.gof.Stats.netDist(gof.tie.weights.1)
print.result.netdist(resDN)
# if this value is above 0.1, the estimation has not yet converged and needs to be re-run
max(abs(resDN$convergenceStatistics))
save.image(temp1.Rdata)
save.image(temp1.RData)
save.image("temp1.RData")
load("temp1.RData")
# check how long it takes to estimate mobility networks
system.time(
{
resDN <- estimateDistributionNetwork(dependentVariable, state, cache, myEffects2,
initialParameters = initEst,
burnInN1 = 200, iterationsN1 = 50, thinningN1 = 500, gainN1 = 0.1,
burnInN2 = 2000, nsubN2 = 4, initGain = 0.25, thinningN2 = 500,
initialIterationsN2 = 25,
iterationsN3 = 500, burnInN3 = 2000, thinningN3 = 500,
parallel = T, cpus = 4,
allowLoops = T,
verbose = T,
returnDeps = T,
multinomialProposal = T,
fish = F)
})
library(MoNAn)
# check how long it takes to estimate mobility networks
system.time(
{
resDN <- estimateDistributionNetwork(dependentVariable, state, cache, myEffects2,
initialParameters = initEst,
burnInN1 = 200, iterationsN1 = 50, thinningN1 = 500, gainN1 = 0.1,
burnInN2 = 2000, nsubN2 = 4, initGain = 0.25, thinningN2 = 500,
initialIterationsN2 = 25,
iterationsN3 = 500, burnInN3 = 2000, thinningN3 = 500,
parallel = T, cpus = 4,
allowLoops = T,
verbose = T,
returnDeps = T,
multinomialProposal = T,
fish = F)
})
library(MoNAn)
load("temp1.RData")
# check how long it takes to estimate mobility networks
set.seed(75)
system.time(
{
resDN <- estimateDistributionNetwork(dependentVariable, state, cache, myEffects2,
initialParameters = initEst,
burnInN1 = 200, iterationsN1 = 50, thinningN1 = 500, gainN1 = 0.1,
burnInN2 = 2000, nsubN2 = 4, initGain = 0.25, thinningN2 = 500,
initialIterationsN2 = 25,
iterationsN3 = 500, burnInN3 = 2000, thinningN3 = 500,
parallel = T, cpus = 4,
allowLoops = T,
verbose = T,
returnDeps = T,
multinomialProposal = T,
fish = F)
})
print.result.netdist(resDN)
# if this value is above 0.1, the estimation has not yet converged and needs to be re-run
max(abs(resDN$convergenceStatistics))
library(MoNAn)
simulateNSteps
MoNAn::simulateOneStep
load("temp1.Rdata")
library(MoNAn)
# check how long it takes to estimate mobility networks
set.seed(75)
system.time(
{
resDN <- estimateDistributionNetwork(dependentVariable, state, cache, myEffects2,
initialParameters = initEst,
burnInN1 = 200, iterationsN1 = 50, thinningN1 = 500, gainN1 = 0.1,
burnInN2 = 2000, nsubN2 = 4, initGain = 0.25, thinningN2 = 500,
initialIterationsN2 = 25,
iterationsN3 = 500, burnInN3 = 2000, thinningN3 = 500,
parallel = T, cpus = 4,
allowLoops = T,
verbose = T,
returnDeps = T,
multinomialProposal = T,
fish = F)
})
library(MoNAn)
load("temp1.RData")
# if this value is above 0.1, the estimation has not yet converged and needs to be re-run
max(abs(resDN$convergenceStatistics))
# if this value is above 0.1, the estimation has not yet converged and needs to be re-run
max(abs(resDN$convergenceStatistics))
resDN
autoCorrelationTestMoNAn(dependentVariable, resDN)
traces <- extractTracesMoNAn(dependentVariable, resDN, myEffects2)
plot(traces)
plot.traces.monan(traces)
myEffects3 <- createEffectsObject(
list(
list('loops'),
list('min_reciprocity'),
list('loops_resource_covar', resource.attribute.index = "sex.f"),
list('min_transitivity')
)
)
test_ME.3 <- scoreTestMoNAn(dependentVariable, resDN, myEffects3)
test_ME.3
print.scoretest.monan(test_ME.3)
getIndegree <- function(cache, dep.var, lvls, ...){
m <- cache[[dep.var]]$valuedNetwork
v <- cbind(lvls, 0)
existing_v <- as.numeric(names(table(colSums(m))))+1
v[existing_v[existing_v %in% lvls],2] <- table(colSums(m))[existing_v %in% lvls]
v[,2]
}
gof.indegree.1 <- gofDistributionNetwork(ans = resDN, simulations = resDN$deps, gofFunction = getIndegree, lvls = 1:100)
plot.gof.Stats.monan(gof.indegree.1)
getTieWeights <- function(cache, dep.var, lvls, ...){
m <- cache[[dep.var]]$valuedNetwork
if(is.null(lvls)) lvls <- 0:max(m)
v <- cbind(lvls, 0)
existing_v <- as.numeric(names(table(m)))+1
v[existing_v[existing_v %in% lvls],2] <- table(m)[existing_v %in% lvls]
v[,2]
}
gof.tie.weights.1 <- gofDistributionNetwork(ans = resDN, simulations = resDN$deps, gofFunction = getTieWeights, lvls = 1:30)
plot(gof.tie.weights.1)
plot.gof.Stats.monan(gof.tie.weights.1)
library(MoNAn)
plot(traces)
resDN
class(resDN)
remove.packages("snow")
remove.packages("snowfall")
library(MoNAn)
library(dfidx)
library(mlogit)
load("~/Privat/Uni/HiWi-Stelle/ERGM/mob_net_PM.RData")
# rename rows
row.names(mobility_PM) <- 1:nrow(mobility_PM)
# how many origin and destination
table(mobility_PM[,1])
table(mobility_PM[,2])
# how many on the diagonal
table(mobility_PM[mobility_PM[,1] == mobility_PM[,2],1])
# generate mobility table for description
mob_table <- matrix(0, 20, 20)
rownames(mob_table) <- colnames(mob_table) <- mctable_PM[,1]
for(i in 1:nrow(mobility_PM)){
mob_table[mobility_PM[i,1], mobility_PM[i,2]] <- mob_table[mobility_PM[i,1], mobility_PM[i,2]] + 1
}
mob_table
##########################
# now we could do some
# plotting etc. but we don't
##########################
mcCodes <- names(table(mobility_PM[,1]))
matchingTable <- cbind(mcCodes, 1:20)
mobTransfers <- cbind(match(mobility_PM$occfather, mcCodes), match(mobility_PM$occresp, mcCodes))
# generate node variable
mesoClass <- mctable_PM$mesoclass
sameMesoClassProf <- 1*(mesoClass == 1) %*% t(1*(mesoClass == 1))
sameMesoManagOffic <- 1*(mesoClass == 2) %*% t(1*(mesoClass == 2))
sameMesoOtherProf <- 1*(mesoClass == 3) %*% t(1*(mesoClass == 3))
sameMesoClass <- sameMesoClassProf + sameMesoManagOffic + sameMesoOtherProf
# generate a random binary variable for individuals
sex.f <- sample(c(0,1), nrow(mobility_PM), replace = T)
##########################
# all of the above was data
# preparation outside of the "package"
##########################
######### now the real thing ###########
# 1. create a "state", i.e. put all needed data in a format that can be used by the "package"
state <- createProcessState(list(
transfers = createEdgelist( mobTransfers, nodeSet = c("micro_class", "micro_class", "people") ),
people = createNodeSet( 1:nrow(mobTransfers) ),
micro_class = createNodeSet(1:nrow(matchingTable)),
sameMesoClass = createNetwork(sameMesoClass, nodeSet = c("micro_class", "micro_class")),
sex.f = createNodeVariable(sex.f, nodeSet = "people"),
siops = createNodeVariable(mctable_PM$siops08, nodeSet = "micro_class", addSim = T)
)
)
# 2. create cache, i.e. an intermediate object that stores useful data transformations
dependentVariable <- "transfers"
cache <- createWeightedCache(state, dependentVariable, resourceCovariates = c("sex.f"))
# 3. create an effects object, i.e. specifying the "independent variables" and endogenous structures
myEffects <- createEffectsObject(
list(
list('loops'),
list('dyadic_covariate', attribute.index = "sameMesoClass")
)
)
myEffects2 <- createEffectsObject(
list(
list('loops'),
list('min_reciprocity'),
list('loops_resource_covar', resource.attribute.index = "sex.f")
)
)
# 3.5 (optional) generate "cheated" estimates as starting values
# these cheated values are the true values in case there are no endogenous parameters
statisticsFrame <- getMultinomialStatistics(state, cache, myEffects, dependentVariable)
mlogit.dataframe <- dfidx(statisticsFrame,
shape = "long",
choice = "choice")
colnames(mlogit.dataframe) <- gsub(" ", "_", colnames(mlogit.dataframe))
IVs <- (colnames(mlogit.dataframe)[2:(ncol(statisticsFrame)-2)])
f <- as.formula(paste("choice ~ 1 + ", paste(IVs, collapse = " + "), "| 0"))
mlogit.results <- mlogit(formula = eval(f), data = mlogit.dataframe, heterosc = F)
summary(mlogit.results)
# same with second effects obj
statisticsFrame2 <- getMultinomialStatistics(state, cache, myEffects2, dependentVariable)
mlogit.dataframe2 <- dfidx(statisticsFrame2,
shape = "long",
choice = "choice")
colnames(mlogit.dataframe2) <- gsub(" ", "_", colnames(mlogit.dataframe2))
IVs <- (colnames(mlogit.dataframe2)[2:(ncol(statisticsFrame2)-2)])
f <- as.formula(paste("choice ~ 1 + ", paste(IVs, collapse = " + "), "| 0"))
mlogit.results2 <- mlogit(formula = eval(f), data = mlogit.dataframe2, heterosc = F)
summary(mlogit.results2)
# 4. estimate it!
initEst <- mlogit.results2$coefficients[1:length(IVs)]
# check how long it takes to estimate mobility networks
set.seed(75)
system.time(
{
resDN <- estimateDistributionNetwork(dependentVariable, state, cache, myEffects2,
initialParameters = initEst,
burnInN1 = 200, iterationsN1 = 50, thinningN1 = 500, gainN1 = 0.1,
burnInN2 = 2000, nsubN2 = 4, initGain = 0.25, thinningN2 = 500,
initialIterationsN2 = 25,
iterationsN3 = 500, burnInN3 = 2000, thinningN3 = 500,
parallel = T, cpus = 4,
allowLoops = T,
verbose = T,
returnDeps = T,
multinomialProposal = T,
fish = F)
})
# if this value is above 0.1, the estimation has not yet converged and needs to be re-run
max(abs(resDN$convergenceStatistics))
resDN
autoCorrelationTestMoNAn(dependentVariable, resDN)
traces <- extractTracesMoNAn(dependentVariable, resDN, myEffects2)
plot(traces)
myEffects3 <- createEffectsObject(
list(
list('loops'),
list('min_reciprocity'),
list('loops_resource_covar', resource.attribute.index = "sex.f"),
list('min_transitivity')
)
)
test_ME.3 <- scoreTestMoNAn(dependentVariable, resDN, myEffects3)
test_ME.3
getIndegree <- function(cache, dep.var, lvls, ...){
m <- cache[[dep.var]]$valuedNetwork
v <- cbind(lvls, 0)
existing_v <- as.numeric(names(table(colSums(m))))+1
v[existing_v[existing_v %in% lvls],2] <- table(colSums(m))[existing_v %in% lvls]
v[,2]
}
gof.indegree.1 <- gofDistributionNetwork(ans = resDN, simulations = resDN$deps, gofFunction = getIndegree, lvls = 1:100)
plot(gof.indegree.1)
getTieWeights <- function(cache, dep.var, lvls, ...){
m <- cache[[dep.var]]$valuedNetwork
if(is.null(lvls)) lvls <- 0:max(m)
v <- cbind(lvls, 0)
existing_v <- as.numeric(names(table(m)))+1
v[existing_v[existing_v %in% lvls],2] <- table(m)[existing_v %in% lvls]
v[,2]
}
gof.tie.weights.1 <- gofDistributionNetwork(ans = resDN, simulations = resDN$deps, gofFunction = getTieWeights, lvls = 1:30)
plot(gof.tie.weights.1)
save.image("~/temp1.RData")
getwd()
save.image("temp1.RData")
sfLibrary(MoNAn)
library(MoNAn)
load(temp1.RData)
load("temp1.RData")
plot(gof.tie.weights.1)
search()
devtools::missing_s3()
??getTieWeights
library(MoNAn)
# check how long it takes to estimate mobility networks
set.seed(75)
system.time(
{
resDN <- estimateDistributionNetwork(dependentVariable, state, cache, myEffects2,
initialParameters = initEst,
burnInN1 = 200, iterationsN1 = 50, thinningN1 = 500, gainN1 = 0.1,
burnInN2 = 2000, nsubN2 = 4, initGain = 0.25, thinningN2 = 500,
initialIterationsN2 = 25,
iterationsN3 = 500, burnInN3 = 2000, thinningN3 = 500,
parallel = T, cpus = 4,
allowLoops = T,
verbose = T,
returnDeps = T,
multinomialProposal = T,
fish = F)
})
library(MoNAn)
# check how long it takes to estimate mobility networks
set.seed(75)
system.time(
{
resDN <- estimateDistributionNetwork(dependentVariable, state, cache, myEffects2,
initialParameters = initEst,
burnInN1 = 200, iterationsN1 = 50, thinningN1 = 500, gainN1 = 0.1,
burnInN2 = 2000, nsubN2 = 4, initGain = 0.25, thinningN2 = 500,
initialIterationsN2 = 25,
iterationsN3 = 500, burnInN3 = 2000, thinningN3 = 500,
parallel = T, cpus = 4,
allowLoops = T,
verbose = T,
returnDeps = T,
multinomialProposal = T,
fish = F)
})
load("temp1.RData")
# check how long it takes to estimate mobility networks
set.seed(75)
system.time(
{
resDN <- estimateDistributionNetwork(dependentVariable, state, cache, myEffects2,
initialParameters = initEst,
burnInN1 = 200, iterationsN1 = 50, thinningN1 = 500, gainN1 = 0.1,
burnInN2 = 2000, nsubN2 = 4, initGain = 0.25, thinningN2 = 500,
initialIterationsN2 = 25,
iterationsN3 = 500, burnInN3 = 2000, thinningN3 = 500,
parallel = T, cpus = 4,
allowLoops = T,
verbose = T,
returnDeps = T,
multinomialProposal = T,
fish = F)
})
# check how long it takes to estimate mobility networks
set.seed(75)
system.time(
{
resDN <- estimateDistributionNetwork(dependentVariable, state, cache, myEffects2,
initialParameters = initEst,
burnInN1 = 200, iterationsN1 = 50, thinningN1 = 500, gainN1 = 0.1,
burnInN2 = 2000, nsubN2 = 4, initGain = 0.25, thinningN2 = 500,
initialIterationsN2 = 25,
iterationsN3 = 500, burnInN3 = 2000, thinningN3 = 500,
parallel = T, cpus = 4,
allowLoops = T,
verbose = T,
returnDeps = T,
multinomialProposal = T,
fish = F)
})
library(MoNAn)
# check how long it takes to estimate mobility networks
set.seed(75)
system.time(
{
resDN <- estimateDistributionNetwork(dependentVariable, state, cache, myEffects2,
initialParameters = initEst,
burnInN1 = 200, iterationsN1 = 50, thinningN1 = 500, gainN1 = 0.1,
burnInN2 = 2000, nsubN2 = 4, initGain = 0.25, thinningN2 = 500,
initialIterationsN2 = 25,
iterationsN3 = 500, burnInN3 = 2000, thinningN3 = 500,
parallel = T, cpus = 4,
allowLoops = T,
verbose = T,
returnDeps = T,
multinomialProposal = T,
fish = F)
})
library(MoNAn)
# check how long it takes to estimate mobility networks
set.seed(75)
system.time(
{
resDN <- estimateDistributionNetwork(dependentVariable, state, cache, myEffects2,
initialParameters = initEst,
burnInN1 = 200, iterationsN1 = 50, thinningN1 = 500, gainN1 = 0.1,
burnInN2 = 2000, nsubN2 = 4, initGain = 0.25, thinningN2 = 500,
initialIterationsN2 = 25,
iterationsN3 = 500, burnInN3 = 2000, thinningN3 = 500,
parallel = T, cpus = 4,
allowLoops = T,
verbose = T,
returnDeps = T,
multinomialProposal = T,
fish = F)
})
load("temp1.RData")
library(MoNAn)
devtools::install_github("perblock/MoNAn")
remove("temp1.RData")
