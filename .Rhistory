# now we could do some
# plotting etc. but we don't
##########################
mcCodes <- names(table(mobility_PM[,1]))
matchingTable <- cbind(mcCodes, 1:20)
mobTransfers <- cbind(match(mobility_PM$occfather, mcCodes), match(mobility_PM$occresp, mcCodes))
# generate node variable
mesoClass <- mctable_PM$mesoclass
sameMesoClassProf <- 1*(mesoClass == 1) %*% t(1*(mesoClass == 1))
sameMesoManagOffic <- 1*(mesoClass == 2) %*% t(1*(mesoClass == 2))
sameMesoOtherProf <- 1*(mesoClass == 3) %*% t(1*(mesoClass == 3))
sameMesoClass <- sameMesoClassProf + sameMesoManagOffic + sameMesoOtherProf
# generate a random binary variable for individuals
sex.f <- sample(c(0,1), nrow(mobility_PM), replace = T)
##########################
# all of the above was data
# preparation outside of the "package"
##########################
######### now the real thing ###########
# 1. create a "state", i.e. put all needed data in a format that can be used by the "package"
state <- createProcessState(list(
transfers = createEdgelist( mobTransfers, nodeSet = c("micro_class", "micro_class", "people") ),
people = createNodeSet( 1:nrow(mobTransfers) ),
micro_class = createNodeSet(1:nrow(matchingTable)),
sameMesoClass = createNetwork(sameMesoClass, nodeSet = c("micro_class", "micro_class")),
sex.f = createNodeVariable(sex.f, nodeSet = "people"),
siops = createNodeVariable(mctable_PM$siops08, nodeSet = "micro_class", addSim = T)
)
)
# 2. create cache, i.e. an intermediate object that stores useful data transformations
dependentVariable <- "transfers"
cache <- createWeightedCache(state, dependentVariable, ressourceCovariates = c("sex.f"))
# 3. create an effects object, i.e. specifying the "independent variables" and endogenous structures
myEffects <- createEffectsObject(
list(
list('loops'),
list('dyadic_covariate', attribute.index = "sameMesoClass")
)
)
myEffects2 <- createEffectsObject(
list(
list('loops'),
list('min_reciprocity_per'),
list('loops_ressource_covar', ressource.attribute.index = "sex.f")
)
)
# 3.5 (optional) generate "cheated" estimates as starting values
# these cheated values are the true values in case there are no endogenous parameters
statisticsFrame <- getMultinomialStatistics(state, cache, myEffects, dependentVariable)
mlogit.dataframe <- dfidx(statisticsFrame,
shape = "long",
choice = "choice")
colnames(mlogit.dataframe) <- gsub(" ", "_", colnames(mlogit.dataframe))
IVs <- (colnames(mlogit.dataframe)[2:(ncol(statisticsFrame)-2)])
f <- as.formula(paste("choice ~ 1 + ", paste(IVs, collapse = " + "), "| 0"))
mlogit.results <- mlogit(formula = eval(f), data = mlogit.dataframe, heterosc = F)
summary(mlogit.results)
# same with second effects obj
statisticsFrame2 <- getMultinomialStatistics(state, cache, myEffects2, dependentVariable)
mlogit.dataframe2 <- dfidx(statisticsFrame2,
shape = "long",
choice = "choice")
colnames(mlogit.dataframe2) <- gsub(" ", "_", colnames(mlogit.dataframe2))
IVs <- (colnames(mlogit.dataframe2)[2:(ncol(statisticsFrame2)-2)])
f <- as.formula(paste("choice ~ 1 + ", paste(IVs, collapse = " + "), "| 0"))
mlogit.results2 <- mlogit(formula = eval(f), data = mlogit.dataframe2, heterosc = F)
summary(mlogit.results2)
# 4. estimate it!
initEst <- mlogit.results2$coefficients[1:length(IVs)]
resDN <- estimateDistributionNetwork(dependentVariable, state, cache, myEffects2,
initialParameters = initEst,
burnInN1 = 200, iterationsN1 = 50, thinningN1 = 2000, gainN1 = 0.1,
burnInN2 = 2000, nsubN2 = 4, initGain = 0.25, thinningN2 = 2000,
initialIterationsN2 = 25,
iterationsN3 = 500, burnInN3 = 2000, thinningN3 = 2000,
parallel = T, cpus = 8,
allowLoops = T,
verbose = T,
returnDeps = T,
multinomialProposal = T,
fish = F)
devtools::install()
devtools::load_all()
getEffectsObject
createEffectsObject
?createEffectsObject
devtools::document()
?createEffectsObject
?estimateDistributionNetwork
createEffectsObject
?estimateDistributionNetwork
load("~/Privat/Uni/HiWi-Stelle/ERGM/mob_net_PM.RData")
library(dfidx)
library(mlogit)
# rename rows
row.names(mobility_PM) <- 1:nrow(mobility_PM)
# how many origin and destination
table(mobility_PM[,1])
table(mobility_PM[,2])
# how many on the diagonal
table(mobility_PM[mobility_PM[,1] == mobility_PM[,2],1])
# generate mobility table for description
mob_table <- matrix(0, 20, 20)
rownames(mob_table) <- colnames(mob_table) <- mctable_PM[,1]
for(i in 1:nrow(mobility_PM)){
mob_table[mobility_PM[i,1], mobility_PM[i,2]] <- mob_table[mobility_PM[i,1], mobility_PM[i,2]] + 1
}
mob_table
##########################
# now we could do some
# plotting etc. but we don't
##########################
mcCodes <- names(table(mobility_PM[,1]))
matchingTable <- cbind(mcCodes, 1:20)
mobTransfers <- cbind(match(mobility_PM$occfather, mcCodes), match(mobility_PM$occresp, mcCodes))
# generate node variable
mesoClass <- mctable_PM$mesoclass
sameMesoClassProf <- 1*(mesoClass == 1) %*% t(1*(mesoClass == 1))
sameMesoManagOffic <- 1*(mesoClass == 2) %*% t(1*(mesoClass == 2))
sameMesoOtherProf <- 1*(mesoClass == 3) %*% t(1*(mesoClass == 3))
sameMesoClass <- sameMesoClassProf + sameMesoManagOffic + sameMesoOtherProf
# generate a random binary variable for individuals
sex.f <- sample(c(0,1), nrow(mobility_PM), replace = T)
##########################
# all of the above was data
# preparation outside of the "package"
##########################
######### now the real thing ###########
# 1. create a "state", i.e. put all needed data in a format that can be used by the "package"
state <- createProcessState(list(
transfers = createEdgelist( mobTransfers, nodeSet = c("micro_class", "micro_class", "people") ),
people = createNodeSet( 1:nrow(mobTransfers) ),
micro_class = createNodeSet(1:nrow(matchingTable)),
sameMesoClass = createNetwork(sameMesoClass, nodeSet = c("micro_class", "micro_class")),
sex.f = createNodeVariable(sex.f, nodeSet = "people"),
siops = createNodeVariable(mctable_PM$siops08, nodeSet = "micro_class", addSim = T)
)
)
# 2. create cache, i.e. an intermediate object that stores useful data transformations
dependentVariable <- "transfers"
cache <- createWeightedCache(state, dependentVariable, ressourceCovariates = c("sex.f"))
# 3. create an effects object, i.e. specifying the "independent variables" and endogenous structures
myEffects <- createEffectsObject(
list(
list('loops'),
list('dyadic_covariate', attribute.index = "sameMesoClass")
)
)
myEffects2 <- createEffectsObject(
list(
list('loops'),
list('min_reciprocity_per'),
list('loops_ressource_covar', ressource.attribute.index = "sex.f")
)
)
# 3.5 (optional) generate "cheated" estimates as starting values
# these cheated values are the true values in case there are no endogenous parameters
statisticsFrame <- getMultinomialStatistics(state, cache, myEffects, dependentVariable)
mlogit.dataframe <- dfidx(statisticsFrame,
shape = "long",
choice = "choice")
colnames(mlogit.dataframe) <- gsub(" ", "_", colnames(mlogit.dataframe))
IVs <- (colnames(mlogit.dataframe)[2:(ncol(statisticsFrame)-2)])
f <- as.formula(paste("choice ~ 1 + ", paste(IVs, collapse = " + "), "| 0"))
mlogit.results <- mlogit(formula = eval(f), data = mlogit.dataframe, heterosc = F)
summary(mlogit.results)
# same with second effects obj
statisticsFrame2 <- getMultinomialStatistics(state, cache, myEffects2, dependentVariable)
mlogit.dataframe2 <- dfidx(statisticsFrame2,
shape = "long",
choice = "choice")
colnames(mlogit.dataframe2) <- gsub(" ", "_", colnames(mlogit.dataframe2))
IVs <- (colnames(mlogit.dataframe2)[2:(ncol(statisticsFrame2)-2)])
f <- as.formula(paste("choice ~ 1 + ", paste(IVs, collapse = " + "), "| 0"))
mlogit.results2 <- mlogit(formula = eval(f), data = mlogit.dataframe2, heterosc = F)
summary(mlogit.results2)
# 4. estimate it!
initEst <- mlogit.results2$coefficients[1:length(IVs)]
resDN <- estimateDistributionNetwork(dependentVariable, state, cache, myEffects2,
initialParameters = initEst,
burnInN1 = 200, iterationsN1 = 50, thinningN1 = 2000, gainN1 = 0.1,
burnInN2 = 2000, nsubN2 = 4, initGain = 0.25, thinningN2 = 2000,
initialIterationsN2 = 25,
iterationsN3 = 500, burnInN3 = 2000, thinningN3 = 2000,
parallel = T, cpus = 8,
allowLoops = T,
verbose = T,
returnDeps = T,
multinomialProposal = T,
fish = F)
print.result.netdist()
print.result.netdist
estimateDistributionNetwork
library(RSiena)
install.packages("RSiena")
library(RSiena)
?sienaModelCreate
?RSiena
s501
??snow
library()
?sfLibrary
devtools::install()
devtools::load_all()
load("~/Privat/Uni/HiWi-Stelle/ERGM/mob_net_PM.RData")
library(dfidx)
library(mlogit)
# rename rows
row.names(mobility_PM) <- 1:nrow(mobility_PM)
# how many origin and destination
table(mobility_PM[,1])
table(mobility_PM[,2])
# how many on the diagonal
table(mobility_PM[mobility_PM[,1] == mobility_PM[,2],1])
# generate mobility table for description
mob_table <- matrix(0, 20, 20)
rownames(mob_table) <- colnames(mob_table) <- mctable_PM[,1]
for(i in 1:nrow(mobility_PM)){
mob_table[mobility_PM[i,1], mobility_PM[i,2]] <- mob_table[mobility_PM[i,1], mobility_PM[i,2]] + 1
}
mob_table
##########################
# now we could do some
# plotting etc. but we don't
##########################
mcCodes <- names(table(mobility_PM[,1]))
matchingTable <- cbind(mcCodes, 1:20)
mobTransfers <- cbind(match(mobility_PM$occfather, mcCodes), match(mobility_PM$occresp, mcCodes))
# generate node variable
mesoClass <- mctable_PM$mesoclass
sameMesoClassProf <- 1*(mesoClass == 1) %*% t(1*(mesoClass == 1))
sameMesoManagOffic <- 1*(mesoClass == 2) %*% t(1*(mesoClass == 2))
sameMesoOtherProf <- 1*(mesoClass == 3) %*% t(1*(mesoClass == 3))
sameMesoClass <- sameMesoClassProf + sameMesoManagOffic + sameMesoOtherProf
# generate a random binary variable for individuals
sex.f <- sample(c(0,1), nrow(mobility_PM), replace = T)
##########################
# all of the above was data
# preparation outside of the "package"
##########################
######### now the real thing ###########
# 1. create a "state", i.e. put all needed data in a format that can be used by the "package"
state <- createProcessState(list(
transfers = createEdgelist( mobTransfers, nodeSet = c("micro_class", "micro_class", "people") ),
people = createNodeSet( 1:nrow(mobTransfers) ),
micro_class = createNodeSet(1:nrow(matchingTable)),
sameMesoClass = createNetwork(sameMesoClass, nodeSet = c("micro_class", "micro_class")),
sex.f = createNodeVariable(sex.f, nodeSet = "people"),
siops = createNodeVariable(mctable_PM$siops08, nodeSet = "micro_class", addSim = T)
)
)
# 2. create cache, i.e. an intermediate object that stores useful data transformations
dependentVariable <- "transfers"
cache <- createWeightedCache(state, dependentVariable, ressourceCovariates = c("sex.f"))
# 3. create an effects object, i.e. specifying the "independent variables" and endogenous structures
myEffects <- createEffectsObject(
list(
list('loops'),
list('dyadic_covariate', attribute.index = "sameMesoClass")
)
)
myEffects2 <- createEffectsObject(
list(
list('loops'),
list('min_reciprocity_per'),
list('loops_ressource_covar', ressource.attribute.index = "sex.f")
)
)
# 3.5 (optional) generate "cheated" estimates as starting values
# these cheated values are the true values in case there are no endogenous parameters
statisticsFrame <- getMultinomialStatistics(state, cache, myEffects, dependentVariable)
mlogit.dataframe <- dfidx(statisticsFrame,
shape = "long",
choice = "choice")
colnames(mlogit.dataframe) <- gsub(" ", "_", colnames(mlogit.dataframe))
IVs <- (colnames(mlogit.dataframe)[2:(ncol(statisticsFrame)-2)])
f <- as.formula(paste("choice ~ 1 + ", paste(IVs, collapse = " + "), "| 0"))
mlogit.results <- mlogit(formula = eval(f), data = mlogit.dataframe, heterosc = F)
summary(mlogit.results)
# same with second effects obj
statisticsFrame2 <- getMultinomialStatistics(state, cache, myEffects2, dependentVariable)
mlogit.dataframe2 <- dfidx(statisticsFrame2,
shape = "long",
choice = "choice")
colnames(mlogit.dataframe2) <- gsub(" ", "_", colnames(mlogit.dataframe2))
IVs <- (colnames(mlogit.dataframe2)[2:(ncol(statisticsFrame2)-2)])
f <- as.formula(paste("choice ~ 1 + ", paste(IVs, collapse = " + "), "| 0"))
mlogit.results2 <- mlogit(formula = eval(f), data = mlogit.dataframe2, heterosc = F)
summary(mlogit.results2)
# 4. estimate it!
initEst <- mlogit.results2$coefficients[1:length(IVs)]
resDN <- estimateDistributionNetwork(dependentVariable, state, cache, myEffects2,
initialParameters = initEst,
burnInN1 = 200, iterationsN1 = 50, thinningN1 = 2000, gainN1 = 0.1,
burnInN2 = 2000, nsubN2 = 4, initGain = 0.25, thinningN2 = 2000,
initialIterationsN2 = 25,
iterationsN3 = 500, burnInN3 = 2000, thinningN3 = 2000,
parallel = T, cpus = 8,
allowLoops = T,
verbose = T,
returnDeps = T,
multinomialProposal = T,
fish = F)
sfLibrary("MoNAn")
?sfLibrary
devtools::install()
devtools::load_all()
library(dfidx)
library(mlogit)
load("/Privat/Uni/HiWi-Stelle/ERGM/mob_net_PM.RData")
load("~/Privat/Uni/HiWi-Stelle/ERGM/mob_net_PM.RData")
# rename rows
row.names(mobility_PM) <- 1:nrow(mobility_PM)
# how many origin and destination
table(mobility_PM[,1])
table(mobility_PM[,2])
# how many on the diagonal
table(mobility_PM[mobility_PM[,1] == mobility_PM[,2],1])
# generate mobility table for description
mob_table <- matrix(0, 20, 20)
rownames(mob_table) <- colnames(mob_table) <- mctable_PM[,1]
for(i in 1:nrow(mobility_PM)){
mob_table[mobility_PM[i,1], mobility_PM[i,2]] <- mob_table[mobility_PM[i,1], mobility_PM[i,2]] + 1
}
mob_table
##########################
# now we could do some
# plotting etc. but we don't
##########################
mcCodes <- names(table(mobility_PM[,1]))
matchingTable <- cbind(mcCodes, 1:20)
mobTransfers <- cbind(match(mobility_PM$occfather, mcCodes), match(mobility_PM$occresp, mcCodes))
# generate node variable
mesoClass <- mctable_PM$mesoclass
sameMesoClassProf <- 1*(mesoClass == 1) %*% t(1*(mesoClass == 1))
sameMesoManagOffic <- 1*(mesoClass == 2) %*% t(1*(mesoClass == 2))
sameMesoOtherProf <- 1*(mesoClass == 3) %*% t(1*(mesoClass == 3))
sameMesoClass <- sameMesoClassProf + sameMesoManagOffic + sameMesoOtherProf
# generate a random binary variable for individuals
sex.f <- sample(c(0,1), nrow(mobility_PM), replace = T)
##########################
# all of the above was data
# preparation outside of the "package"
##########################
######### now the real thing ###########
# 1. create a "state", i.e. put all needed data in a format that can be used by the "package"
state <- createProcessState(list(
transfers = createEdgelist( mobTransfers, nodeSet = c("micro_class", "micro_class", "people") ),
people = createNodeSet( 1:nrow(mobTransfers) ),
micro_class = createNodeSet(1:nrow(matchingTable)),
sameMesoClass = createNetwork(sameMesoClass, nodeSet = c("micro_class", "micro_class")),
sex.f = createNodeVariable(sex.f, nodeSet = "people"),
siops = createNodeVariable(mctable_PM$siops08, nodeSet = "micro_class", addSim = T)
)
)
# 2. create cache, i.e. an intermediate object that stores useful data transformations
dependentVariable <- "transfers"
cache <- createWeightedCache(state, dependentVariable, ressourceCovariates = c("sex.f"))
# 3. create an effects object, i.e. specifying the "independent variables" and endogenous structures
myEffects <- createEffectsObject(
list(
list('loops'),
list('dyadic_covariate', attribute.index = "sameMesoClass")
)
)
myEffects2 <- createEffectsObject(
list(
list('loops'),
list('min_reciprocity_per'),
list('loops_ressource_covar', ressource.attribute.index = "sex.f")
)
)
# 3.5 (optional) generate "cheated" estimates as starting values
# these cheated values are the true values in case there are no endogenous parameters
statisticsFrame <- getMultinomialStatistics(state, cache, myEffects, dependentVariable)
mlogit.dataframe <- dfidx(statisticsFrame,
shape = "long",
choice = "choice")
colnames(mlogit.dataframe) <- gsub(" ", "_", colnames(mlogit.dataframe))
IVs <- (colnames(mlogit.dataframe)[2:(ncol(statisticsFrame)-2)])
f <- as.formula(paste("choice ~ 1 + ", paste(IVs, collapse = " + "), "| 0"))
mlogit.results <- mlogit(formula = eval(f), data = mlogit.dataframe, heterosc = F)
summary(mlogit.results)
# same with second effects obj
statisticsFrame2 <- getMultinomialStatistics(state, cache, myEffects2, dependentVariable)
mlogit.dataframe2 <- dfidx(statisticsFrame2,
shape = "long",
choice = "choice")
colnames(mlogit.dataframe2) <- gsub(" ", "_", colnames(mlogit.dataframe2))
IVs <- (colnames(mlogit.dataframe2)[2:(ncol(statisticsFrame2)-2)])
f <- as.formula(paste("choice ~ 1 + ", paste(IVs, collapse = " + "), "| 0"))
mlogit.results2 <- mlogit(formula = eval(f), data = mlogit.dataframe2, heterosc = F)
summary(mlogit.results2)
# 4. estimate it!
initEst <- mlogit.results2$coefficients[1:length(IVs)]
resDN <- estimateDistributionNetwork(dependentVariable, state, cache, myEffects2,
initialParameters = initEst,
burnInN1 = 200, iterationsN1 = 50, thinningN1 = 2000, gainN1 = 0.1,
burnInN2 = 2000, nsubN2 = 4, initGain = 0.25, thinningN2 = 2000,
initialIterationsN2 = 25,
iterationsN3 = 500, burnInN3 = 2000, thinningN3 = 2000,
parallel = T, cpus = 8,
allowLoops = T,
verbose = T,
returnDeps = T,
multinomialProposal = T,
fish = F)
sfLibrary("MoNAn")
sfLibrary(MoNAn::runSubphase2())
sfLibrary("MoNAn::runSubphase2()")
sfLibrary(MoNAn)
devtools::install()
devtools::load_all()
library(dfidx)
library(mlogit)
load("~/Privat/Uni/HiWi-Stelle/ERGM/mob_net_PM.RData")
row.names(mobility_PM) <- 1:nrow(mobility_PM)
# how many origin and destination
table(mobility_PM[,1])
table(mobility_PM[,2])
# how many on the diagonal
table(mobility_PM[mobility_PM[,1] == mobility_PM[,2],1])
# generate mobility table for description
mob_table <- matrix(0, 20, 20)
rownames(mob_table) <- colnames(mob_table) <- mctable_PM[,1]
for(i in 1:nrow(mobility_PM)){
mob_table[mobility_PM[i,1], mobility_PM[i,2]] <- mob_table[mobility_PM[i,1], mobility_PM[i,2]] + 1
}
mob_table
##########################
# now we could do some
# plotting etc. but we don't
##########################
mcCodes <- names(table(mobility_PM[,1]))
matchingTable <- cbind(mcCodes, 1:20)
mobTransfers <- cbind(match(mobility_PM$occfather, mcCodes), match(mobility_PM$occresp, mcCodes))
# generate node variable
mesoClass <- mctable_PM$mesoclass
sameMesoClassProf <- 1*(mesoClass == 1) %*% t(1*(mesoClass == 1))
sameMesoManagOffic <- 1*(mesoClass == 2) %*% t(1*(mesoClass == 2))
sameMesoOtherProf <- 1*(mesoClass == 3) %*% t(1*(mesoClass == 3))
sameMesoClass <- sameMesoClassProf + sameMesoManagOffic + sameMesoOtherProf
# generate a random binary variable for individuals
sex.f <- sample(c(0,1), nrow(mobility_PM), replace = T)
##########################
# all of the above was data
# preparation outside of the "package"
##########################
######### now the real thing ###########
# 1. create a "state", i.e. put all needed data in a format that can be used by the "package"
state <- createProcessState(list(
transfers = createEdgelist( mobTransfers, nodeSet = c("micro_class", "micro_class", "people") ),
people = createNodeSet( 1:nrow(mobTransfers) ),
micro_class = createNodeSet(1:nrow(matchingTable)),
sameMesoClass = createNetwork(sameMesoClass, nodeSet = c("micro_class", "micro_class")),
sex.f = createNodeVariable(sex.f, nodeSet = "people"),
siops = createNodeVariable(mctable_PM$siops08, nodeSet = "micro_class", addSim = T)
)
)
# 2. create cache, i.e. an intermediate object that stores useful data transformations
dependentVariable <- "transfers"
cache <- createWeightedCache(state, dependentVariable, ressourceCovariates = c("sex.f"))
# 3. create an effects object, i.e. specifying the "independent variables" and endogenous structures
myEffects <- createEffectsObject(
list(
list('loops'),
list('dyadic_covariate', attribute.index = "sameMesoClass")
)
)
myEffects2 <- createEffectsObject(
list(
list('loops'),
list('min_reciprocity_per'),
list('loops_ressource_covar', ressource.attribute.index = "sex.f")
)
)
# 3.5 (optional) generate "cheated" estimates as starting values
# these cheated values are the true values in case there are no endogenous parameters
statisticsFrame <- getMultinomialStatistics(state, cache, myEffects, dependentVariable)
mlogit.dataframe <- dfidx(statisticsFrame,
shape = "long",
choice = "choice")
colnames(mlogit.dataframe) <- gsub(" ", "_", colnames(mlogit.dataframe))
IVs <- (colnames(mlogit.dataframe)[2:(ncol(statisticsFrame)-2)])
f <- as.formula(paste("choice ~ 1 + ", paste(IVs, collapse = " + "), "| 0"))
mlogit.results <- mlogit(formula = eval(f), data = mlogit.dataframe, heterosc = F)
summary(mlogit.results)
# same with second effects obj
statisticsFrame2 <- getMultinomialStatistics(state, cache, myEffects2, dependentVariable)
mlogit.dataframe2 <- dfidx(statisticsFrame2,
shape = "long",
choice = "choice")
colnames(mlogit.dataframe2) <- gsub(" ", "_", colnames(mlogit.dataframe2))
IVs <- (colnames(mlogit.dataframe2)[2:(ncol(statisticsFrame2)-2)])
f <- as.formula(paste("choice ~ 1 + ", paste(IVs, collapse = " + "), "| 0"))
mlogit.results2 <- mlogit(formula = eval(f), data = mlogit.dataframe2, heterosc = F)
summary(mlogit.results2)
# 4. estimate it!
initEst <- mlogit.results2$coefficients[1:length(IVs)]
resDN <- estimateDistributionNetwork(dependentVariable, state, cache, myEffects2,
initialParameters = initEst,
burnInN1 = 200, iterationsN1 = 50, thinningN1 = 2000, gainN1 = 0.1,
burnInN2 = 2000, nsubN2 = 4, initGain = 0.25, thinningN2 = 2000,
initialIterationsN2 = 25,
iterationsN3 = 500, burnInN3 = 2000, thinningN3 = 2000,
parallel = T, cpus = 8,
allowLoops = T,
verbose = T,
returnDeps = T,
multinomialProposal = T,
fish = F)
sfLibrary(MoNAn, simulateStatisticVectors())
