% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/3_coreFunctions.R, R/4_auxiliaryFunctions.R
\name{estimateMobilityNetwork}
\alias{estimateMobilityNetwork}
\alias{estimateDistributionNetwork}
\alias{print.result.monan}
\title{estimateMobilityNetwork}
\usage{
estimateMobilityNetwork(
  dep.var,
  state,
  cache,
  effects,
  initialParameters = NULL,
  prevAns = NULL,
  burnInN1 = 500,
  iterationsN1 = 200,
  thinningN1 = 20,
  gainN1 = 1,
  burnInN2 = burnInN1,
  nsubN2 = 6,
  initGain = 0.02,
  thinningN2 = 100,
  initialIterationsN2 = 50,
  iterationsN3 = 1000,
  burnInN3 = 2000,
  thinningN3 = 30,
  allowLoops = NULL,
  parallel = FALSE,
  cpus = 3,
  verbose = FALSE,
  returnDeps = FALSE,
  multinomialProposal = FALSE,
  fish = FALSE
)

estimateDistributionNetwork(
  dep.var,
  state,
  cache,
  effects,
  initialParameters = NULL,
  prevAns = NULL,
  burnInN1 = 500,
  iterationsN1 = 200,
  thinningN1 = 20,
  gainN1 = 1,
  burnInN2 = burnInN1,
  nsubN2 = 6,
  initGain = 0.02,
  thinningN2 = 100,
  initialIterationsN2 = 50,
  iterationsN3 = 1000,
  burnInN3 = 2000,
  thinningN3 = 30,
  allowLoops = NULL,
  parallel = FALSE,
  cpus = 3,
  verbose = FALSE,
  returnDeps = FALSE,
  multinomialProposal = FALSE,
  fish = FALSE
)

\method{print}{result.monan}(x, covMat = FALSE, ...)
}
\arguments{
\item{dep.var}{The outcome variable that is modelled.}

\item{state}{A monan state object that contains all relevant information about
the outcome in the form of an edgelist, the nodesets, and covariates.}

\item{cache}{A monan cache object created from the same state object that is
used in the estimation}

\item{effects}{An effect object that specifies the model.}

\item{initialParameters}{Starting values for the parameters. Using starting
values e.g. from a multinomial logit model (see getMultinomialStatistics())
increases the chances of model convergence in the first run of the estimation
considerably.}

\item{prevAns}{If a previous estimation did not yield satisfactory convergence,
the outcome object of that estimation should be specified here to provide new
starting values for the estimation.}

\item{burnInN1}{The number of simulation steps before the first draw in Phase 1.
A recommended value is at least n_Individuals * n_locations if
multinomialProposal = F, and at least n_Individuals if multinomialProposal = T}

\item{iterationsN1}{The number of draws taken in Phase 1.
A recommended value is at least 4 * n_effects.
If the value is too low, there will be an error in Phase 1.}

\item{thinningN1}{The number of simulation steps between two draws in Phase 1.
A recommended value is at least 0.5 * n_Individuals * n_locations if
multinomialProposal = F, and at least n_Individuals if multinomialProposal = T.}

\item{gainN1}{The size of the updating step after Phase 1. A conservative
value is 0, values higher than 0.25 are courageous.}

\item{burnInN2}{The number of simulation steps before the first draw in Phase 2.
A recommended value is at least n_Individuals * n_locations if
multinomialProposal = F, and at least n_Individuals if multinomialProposal = T}

\item{nsubN2}{Number of subphases in Phase 2. In case this is the first
estimation, 4 subphases are recommended. If convergence in a previous estimation
was close, then 1-2 subphases should be enough.}

\item{initGain}{The magnitude of parameter updates in the first subphase of
Phase 2. Values of around 0.2 are recommended.}

\item{thinningN2}{The number of simulation steps between two draws in Phase 2.
A recommended value is at least 0.5 * n_Individuals * n_locations if
multinomialProposal = F, and at least n_Individuals if multinomialProposal = T.}

\item{initialIterationsN2}{The number of draws taken in subpphase 1 of Phase 2.
For first estimations, a recommended value is around 20-50.
Note that in later subphases, the number
of iterations increases.
If this is a further estimation to improve convergence, higher values (100+)
are recommended.
If the value is too low, the model might take more runs to converge.}

\item{iterationsN3}{Number of draws in Phase 3.
Recommended are at the very least 500.
In case this value is too low, the outcome might erroneously indicate a lack
of convergence.}

\item{burnInN3}{The number of simulation steps before the first draw in Phase 3.
A recommended value is at least 3 * n_Individuals * n_locations if
multinomialProposal = F, and at least 3 * n_Individuals if multinomialProposal = T}

\item{thinningN3}{The number of simulation steps between two draws in Phase 3.
A recommended value is at least n_Individuals * n_locations if
multinomialProposal = F, and at least 2 * n_Individuals if multinomialProposal = T.
In case this value is too low, the outcome might erroneously indicate a lack
of convergence.}

\item{allowLoops}{Logical: can individuals/resources stay in their origin?}

\item{parallel}{Computation on multiple cores?}

\item{cpus}{Number of cores for computation in case parallel = T.}

\item{verbose}{Logical: display information about estimation progress in the console?}

\item{returnDeps}{Logical: should the simulated values of Phase 3 be stored and returned?
This is necessary to run GoF tests.
Note that this might result in very large objects.}

\item{multinomialProposal}{How should the next possible outcome in the simulation chains
be sampled? If TRUE, fewer simulation steps are needed, but each simulation
step takes considerably longer.}

\item{fish}{Logical: display a fish?}

\item{x}{An ans object resulting from an estimation with estimateMobilityNetwork()}

\item{covMat}{Logical indicating whether the covariance matrix should be printed}

\item{...}{For internal use only}
}
\value{
A monan results object that contains the estimates, standard errors,
and convergence statistics. Furthermore, the covariance matrix used to calculate
the standard errors is included, which also shows colinearity between effects.
In case returnDeps = TRUE, the simulations of Phase 3 are included, too.
}
\description{
The core function of the package in which the model for the analysis of
mobility tables is estimated.
}
\examples{
\dontrun{
# estimate mobility network
myResDN <- estimateMobilityNetwork(myDependentVariable,
  myState, myCache, myEffects,
  initialParameters = NULL,
  burnInN1 = 1500, iterationsN1 = 50,
  thinningN1 = 750, gainN1 = 0.1,
  burnInN2 = 7500, nsubN2 = 4,
  initGain = 0.2, thinningN2 = 1500,
  initialIterationsN2 = 25,
  iterationsN3 = 500, burnInN3 = 7500,
  thinningN3 = 3750,
  parallel = TRUE, cpus = 4,
  allowLoops = TRUE,
  verbose = TRUE,
  returnDeps = TRUE,
  multinomialProposal = FALSE,
  fish = FALSE
)

myResDN

# estimate mobility network again based on previous results to improve convergence
myResDN <- estimateMobilityNetwork(myDependentVariable,
  myState, myCache, myEffects,
  prevAns = myResDN,
  burnInN1 = 1500, iterationsN1 = 50,
  thinningN1 = 750, gainN1 = 0.1,
  burnInN2 = 7500, nsubN2 = 4,
  initGain = 0.2, thinningN2 = 3000,
  initialIterationsN2 = 40,
  iterationsN3 = 500, burnInN3 = 15000,
  thinningN3 = 7500,
  parallel = TRUE, cpus = 4,
  allowLoops = TRUE,
  verbose = TRUE,
  returnDeps = TRUE,
  multinomialProposal = FALSE,
  fish = FALSE
)
}
myResDN
}
\seealso{
\code{\link[=createProcessState]{createProcessState()}}, \code{\link[=createWeightedCache]{createWeightedCache()}},
\code{\link[=createEffectsObject]{createEffectsObject()}}
}
